1. Хуки
    Основные хуки

    useState
    const [state, setState] = useState(initialState);
    Возвращает значение с состоянием и функцию для его обновления.
    Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным в качестве первого аргумента (initialState).
    Функция setState используется для обновления состояния. Она принимает новое значение состояния и ставит в очередь повторный рендер компонента.
    setState может принимает или новое значение или функцию
    Например: setState(prev => prev + 1) Это нужно для того, чтоб быть уверенным, что мы работаем с предыдушим состоянием
    В setState можно передать 2 опциональный параметр. Это функция, которая будет вызвана, когда реакт полностью закончит цикл изменения состояния


    useEffect(() => {
     .....
    }, []);
    Принимает функцию, которая содержит императивный код, возможно, с эффектами.
    Если массив зависимостей пустой [] - то выполняется только при первом рендере (componentDidMount)
    Если с какими-то записимостями [a, b] - то выполняется при их изменении
    Если без массива - то выпоняется при каждом рендере
    Мутации, подписки, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента
    (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.
    Вместо этого используйте useEffect. Функция, переданная в useEffect, будет запущена после того, как рендер будет зафиксирован на экране.
    По умолчанию эффекты запускаются после каждого завершённого рендеринга, но вы можете решить запускать их только при изменении определённых значений.
    useEffect - это хук, который позволяет использовать сайд эффект.
    В классах его аналогом было использование componentDidMount, componentDidUpdate и componentWillUnmount.
    В нем можно делать подписки, отправлять запросы управлять анимацией и т. д.
    const [data, setData] = useState(null);
    useEffect(() => {
      const controller = new AbortController()
      fetchData(controller.signal).then(setData)

      return () => controller.abort()
    }, [fetchData, setData])
    УТЕЧКА ПАМЯТИ (cleanUp)
    Сброс, когда компонента умирает или useEffect заново срабатывает
    Сначала запускается сброс(т.е. наш return), а потом уже выполняется тело useEffect
    return () => {
    .... some code что нам нужно оборвать, например, убрать какой-нибудь обработчик событий или остоновить setInterval
    }


    useContext
    const value = useContext(MyContext);


    useSelector
    Из react-redux
    const todolists = useSelector<AppRootStateType, Array<TodolistType>>(state => state.todolists)


    useDispatch
    Из react-redux
    const dispatch = useDispatch();

    Дополнительные хуки


    useReducer
    const [state, dispatch] = useReducer(reducer, initialArg, init);
    Альтернатива для useState. Принимает редюсер типа (state, action) => newState и возвращает текущее состояние в паре с методом dispatch.
    Хук useReducer обычно предпочтительнее useState, когда у вас сложная логика состояния,
    которая включает в себя несколько значений, или когда следующее состояние зависит от предыдущего.


    useCallback
    const memoizedCallback = useCallback(
      () => {
        doSomething(a, b);
      },
      [a, b],
    );
    Возвращает мемоизированный колбэк.
    Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только,
    если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам,
    которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate).


    useMemo
    useCallback и useMemo предназначены для оптимизации. useCallback получает на функцию и массив аргументов,
    и возвращает одну и туже функцию, до тех пор, пока аргументы не изменились. useMemo отличается тем, что он возвращает не саму функцию,
    а результат её выполнения. По большому счету они являются взаимозаменямыми.
    Таким образом, useMemo используется для сохранения результатов тяжёлых вычислений, например обработка массива.
    const data = useMemo(() => array.map(mapper).filter(predicate).reduce(reducer), [array])
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
    Возвращает мемоизированное значение.
    Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда,
    когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере.


    useCallback
    А useCallback используется, когда важна постоянность ссылок на функцию. Например, когда мы передаём ссылку в компонент,
    который использует React.PureComponent или React.memo, или, когда функция используется в качестве аргумента в других хуках


    useRef
    const refContainer = useRef(initialValue);
    Обычный случай использования — это доступ к потомку в императивном стиле:
    function TextInputWithFocusButton() {
      const inputEl = useRef(null);
      const onButtonClick = () => {
        // `current` указывает на смонтированный элемент `input`
        inputEl.current.focus();
      };

      return (
        <>
          <input ref={inputEl} type="text" />
          <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
        </>
      );
    }


    useImperativeHandle
    useImperativeHandle(ref, createHandle, [deps])
    useImperativeHandle настраивает значение экземпляра, которое предоставляется родительским компонентам при использовании ref.
    Как всегда, в большинстве случаев следует избегать императивного кода, использующего ссылки. useImperativeHandle должен использоваться с forwardRef:
    function FancyInput(props, ref) {
      const inputRef = useRef();
      useImperativeHandle(ref, () => ({
        focus: () => {
          inputRef.current.focus();
        }
      }));
      return <input ref={inputRef} ... />;
    }
    FancyInput = forwardRef(FancyInput);


    useLayoutEffect
    Сигнатура идентична useEffect, но этот хук запускается синхронно после всех изменений DOM.
    Используйте его для чтения макета из DOM и синхронного повторного рендеринга. Обновления, запланированные внутри useLayoutEffect,
    будут полностью применены синхронно перед тем, как браузер получит шанс осуществить отрисовку.
    Предпочитайте стандартный useEffect, когда это возможно, чтобы избежать блокировки визуальных обновлений.

    useDebugValue
    useDebugValue(value)
    useDebugValue может использоваться для отображения метки для пользовательских хуков в React DevTools.
    function useFriendStatus(friendID) {
      const [isOnline, setIsOnline] = useState(null);
      // ...
      // Показывать ярлык в DevTools рядом с этим хуком
      // например, «Статус друга: В сети»
      useDebugValue(isOnline ? 'В сети' : 'Не в сети');

      return isOnline;
    }



2. HOC
    Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент.
    const EnhancedComponent = higherOrderComponent(WrappedComponent);


    withRouter
    const NavbarWithRouter = withRouter(Navbar);


    connect
    // `connect` из react-redux
    const ConnectedComment = connect(commentSelector, commentActions)(CommentList);

    // Вызов функции connect возвращает другую функцию
    const enhance = connect(commentListSelector, commentListActions);
    // Эта функция и есть HOC. Она возвращает компонент, подключённый к хранилищу Redux
    const ConnectedComment = enhance(CommentList);


    React.memo()
    React.memo(Component)
    Когда компонент заключен в оболочку React.memo(), React визуализирует компонент и запоминает результат.
    Перед следующим рендерингом, если новые реквизиты такие же, React повторно использует мемоизированный результат, пропуская следующий рендеринг .



3. React.createContext
    const MyContext = React.createContext(defaultValue);

    <MyContext.Provider value={....some value} />

    <MyContext.Consumer>
        {value}
    </MyContext.Consumer>
    Создаёт объект Context. Когда React рендерит компонент, который подписан на этот объект,
    React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
    Аргумент defaultValue используется только в том случае, если для компонента нет подходящего Provider выше в дереве.


4. React.pureComponent аналог React.memo. Или аналог метод shouldComponentUpdate(nextProps, nextState)


5. Provider
    <Provider store={store}>
        <App/>
    </Provider>

    <Provider> компонент делает Redux store доступным для всех вложенных компонентов , которые должны обращаться к хранилищу Redux.



6. Что такое паттерн в реакте и какие знаешь?
    Stateful и Stateless Components
    Компоненты в React содержащие внутреннее состояние — state, называются Stateful. Без него — Stateless.
    Многие заблуждаются думая, что Stateless компоненты могут быть только в виде function.
    Единственное, что отличает Stateless от Stateful компонентов— это отсутствие внутреннего состояния.


    Container и Presentational Components
    Когда нам предстоит работа с данными из вне (серверные запросы, redux) и их дальнейшее отображение,
    в игру вступают Container и Presentational компоненты.
    Container — компонент, в котором принимают и работают с данными.
    Presentational — компонент, в котором отображают данные.


    Higher-Order Components
    Или просто HOC — это обычная функция которая принимает компоненту как аргумент и возвращает новую компоненту.
    Обычно HOC применяется когда нужно переиспользовать повторяющуюся логику, применяемую к ряду компонентов.


    Render Callbacks
    Ещё один способ сделать логику переиспользуемой. Это становится возможным при помощи передаваемого children-а в виде функции.


7. Что такое Node Js
     Программная платформа, основанная на движке V8 (транслирующем JavaScript в машинный код),
    превращающая JavaScript из узкоспециализированного языка в язык общего назначения.
    Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API,
    подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода.
    Node.js применяется преимущественно на сервере, выполняя роль веб-сервера,
    но есть возможность разрабатывать на Node.js и десктопные оконные приложения.
    В основе Node.js лежит событийно-ориентированное и асинхронное (или реактивное) программирование с неблокирующим вводом/выводом.



8. SPA (Single Page Application)
    Это веб-приложение или веб-сайт, использующий единственный HTML-документ как оболочку для всех веб-страниц и
    организующий взаимодействие с пользователем через динамически подгружаемые HTML, CSS, JavaScript[1], обычно посредством AJAX.



9. Функциональная компонента (презентационная(presentational), без состояния(stateless), тупая(dumb) )
    Это по-сути функция, принимающая пропсы и на их основе возвращающая JSX-разметку.
    1. Тупая(dumb) --- не зависят от остальной части приложения,
                       получают данные и колбэки исключительно через props
                       имеют свой css файл
                       изредка имеют свой state
                       могут использовать другие глупые компоненты
                       примеры: Page, Sidebar, Story, UserInfo, List

    2. Презентационные компоненты --- сочетаются с представлением или отвечают за отображение.
    Эти компоненты принимают props из своего контейнера и рендерят их. Все, что связано с описанием пользовательского интерфейса,
    должно быть здесь.
    Презентационные компоненты могут повторно использоваться и должны оставаться отделенными от поведенческого слоя.
    Презентационный компонент получает данные и коллбеки исключительно через props, и когда происходит событие,
    например нажатие кнопки, он вызывает коллбек к компоненту контейнера через props для вызова метода обработки событий.

    3. Без состояния(stateless)
    Вы можете использовать либо функцию, либо класс для создания компонентов без состояния.
    Но если вам не нужно использовать хуки жизненного цикла в ваших компонентах,
    желательно перейти на функциональные компоненты без состояния. Есть много преимуществ, если вы решили использовать функциональные
    компоненты без state; они просты в написании, понимании и тестировании, и вы можете вообще избегать ключевого слова this.
    Недостатком является то, что вы не можете использовать хуки жизненного цикла.
    Метод жизненного цикла ShouldComponentUpdate() часто используется для оптимизации производительности и для ручного управления тем,
    что получает рендеринг. Вы не можете использовать это с функциональными компонентами. Refs также не поддерживаются.



10. Props
    Пропс- - это объект, который мы используем для передачи каких-либо данных компоненте



11. Map
    Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
    Синтаксис:
    let result = arr.map(function(item, index, array) {
      // возвращается новое значение вместо элемента
    });



12. Route
    Маршрутизация
    Router определяет набор маршрутов и, когда к приложению, приходит запрос, то Router выполняет сопоставление запроса с маршрутами.
    И если какой-то маршрут совпадает с URL запроса, то этот маршрут выбирается для обработки запроса.

    Каждый маршрут представляет объект Route. Он имеет ряд атрибутов.
     <Router>
          <div>
            <nav>
              <ul>
                <li>
                  <Link to="/">Home</Link>
                </li>
                <li>
                  <Link to="/about">About</Link>
                </li>
                <li>
                  <Link to="/users">Users</Link>
                </li>
              </ul>
            </nav>

            {/* A <Switch> looks through its children <Route>s and
                renders the first one that matches the current URL. */}
            <Switch>
              <Route path="/about">
                <About />
              </Route>
              <Route path="/users">
                <Users />
              </Route>
              <Route path="/">
                <Home />
              </Route>
            </Switch>
          </div>
     </Router>



13. Что такое reducer?
    reducer(state, action)
    Это чистая функция(без сайд эффектов), которая принимает state, action. Если нужно применяет action к state и
    возвращает новый state или возвращает изначальный state, если action не подошел.



14. HOC higher order component
    Компонент высшего порядка — это функция, которая принимает компонент,что-либо производит с ним и возвращает новый компонент.
    const EnhancedComponent = higherOrderComponent(WrappedComponent);
    Если обычный компонент преобразует пропсы в UI, то компонент высшего порядка преобразует компонент в другой компонент.
    HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.



15. VD Virtual DOM
    Совокупность объектов, на основне которых потом будет строиться настоящий DOM



16. TDD (test driving development)   (BDD (Behavior driving development))
    Разработка посредствам тестирования. То есть сначала пишет тесты,а потом на них пишем код



17. Определения.
    Идемпотентность — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом.

    Функция называется детерминированной тогда, когда для одних и тех же входных аргументов она возвращает один и тот же результат.
    Например, функция, переворачивающая строку, детерминированная.

    Иммутабельность (Неизменяемым) называется объект, состояние которого не может быть изменено после создания.
    Результатом любой модификации такого объекта всегда будет новый объект, при этом старый объект не изменится.



18. Динамическая диспетчеризация
    const handlers = {
      [LOADING]: (state) => {
        return {...state, isLoading: true}
      },
      DEFAULT: (state) => state,
    }

    export const userReducer = (state, action) => {
      const handler = handlers[action.type] || handlers.DEFAULT
      return handler(state, action)
    }



19. Жизненные циклы компонент
    render(): рендеринг компонента

    componentDidMount(): вызывается после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам

    componentWillUnmount(): вызывается перед удалением компонента из DOM

    shouldComponentUpdate(nextProps, nextState): вызывается каждый раз при обновлении объекта props или state.
    В качестве параметра передаются новый объект props и state. Эта функция должна возвращать true (надо делать обновление) или false (игнорировать обновление).
    По умолчанию возвращается true. Но если функция будет возвращать false, то тем самым мы отключим обновление компонента,
    а последующие функции не будут срабатывать.

    getSnapshotBeforeUpdate(prevProps, prevState): вызывается непосредственно перед компонента.
    Он позволяет компоненту получить информацию из DOM перед возможным обновлением. Возвращает в качестве значения какой-то отдельный аспект,
    который передается в качестве третьего параметра в метод componentDidUpdate() и может учитываться в componentDidUpdate при обновлении.
    Если нечего возвращать, то возвращается значение null

    componentDidUpdate(prevProps, prevState, snapshot): вызывается сразу после обновления компонента (если shouldComponentUpdate возвращает true).
    В качестве параметров передаются старые значения объектов props и state. Третий параметр - значение, которое возвращает метод getSnapshotBeforeUpdate



20. Ref
    Рефы дают возможность получить доступ к DOM-узлам или React-элементам, созданным в рендер-методе.
    Ситуации, в которых использование рефов является оправданным:
    Управление фокусом, выделение текста или воспроизведение медиа,
    Императивный вызов анимаций,
    Интеграция со сторонними DOM-библиотеками.

    class MyComponent extends React.Component {
      constructor(props) {
        super(props);
        this.myRef = React.createRef();
      }
      render() {
        return <div ref={this.myRef} />;
      }
    }

    Для функциональных компонент:
    function TextInputWithFocusButton() {
      const inputEl = useRef(null);
      const onButtonClick = () => {
        // `current` указывает на смонтированный элемент `input`
        inputEl.current.focus();
      };

      return (
        <>
          <input ref={inputEl} type="text" />
          <button onClick={onButtonClick}>Установить фокус на поле ввода</button>
        </>
      );
    }



21. Дженерики
    Обобщённый тип (обобщение, дженерик) позволяет резервировать место для типа, который будет заменён на конкретный,
    переданный пользователем, при вызове функции или метода, а также при работе с классами.

    function identity<T>(arg: T): T {
        return arg;
    }



22. Методы жизненного цикла в правильном порядке при рендеринге
    constructor                          (инициализация: setup state and props)

    componentWillMount
    render                                           Mounting(монтаж)
    componentDidMount

    shouldComponentUpdate
    componentWillUpdate                              Updation
    componentDidUpdate

    componentWillUnmount                             Unmounting



23. Контролируемый и неконтролируемый компонент
    Контролируемый компонент - это где присутствует стейт, за которым мы следим (например, инпут с setState или с хуком)

    Неконтролируемый компонент - это где есть стейт, но мы его не обрабатывает. Например, textarea, когда мы что-то
    вписываем, но не взаимодействуем со стейтом.


24. Что такое фрагмент?
    <> </>



25. shouldComponentUpdate(nextProps, nextState)
    Вызывается каждый раз при обновлении объекта props или state.
    Служит для оптимизации рендеринга реакта
    Танный метод возвращает либо true либо false и на основе этого происходит или нет рендеринг



26. Store
    Это простой объект содержащий в себе состояние нашего приложиния и имеющий данные методы:
    getState()
    dispatch(action)
    subscribe(listener)          It will be called any time an action is dispatched
    replaceReducer(nextReducer)   Replaces the reducer currently used by the store to calculate the state.



27. Что нельзя делать в методе render()?
    Изменение нашего стейта(например, вызывать setState). Так как тогда мы зациклим перерендеринг компоненты
    Это должна быть чистая функция



28. Какие типы middleware есть в redux?
    reduxThunk, reduxSaga, reduxPromise


29. Что такое pureComponents?
    Если мы будем наследоваться не просто от компоненты, а от PureComponent, то React автоматически
    реализует метод shouldComponentUpdate и оптимизирует наш компонент



30. В чем разница между useRef и createRef?
        Функция createRef для классовых компонент и мы не можем ее использовать в функциональных (всегда возвращает новую ссылку)
        useRef создает объект, с тем состоянием, который мы создавали при начальном рендеренге



31. Что такое props drilling и как этого избежать?
    Когда по дереву приложения пробрасываем пропсы до глубоких вложенностей и это становится сложно поддерживать
    Избежать: использовать Provider для классовых компонент или хуки useSelector для функциональных + redux



32. Разница между MVC и Flux?
    У MVC есть проблемы при работе с данными: сложно предсказывать, где изменятся данные
    Flux(и потом Redux) где данные отделены от отображения



33. Что такое mapStateToProps и mapDispatchToProps?
    Это функции по сути обычные враперы. Они пришли в функции connect из react-redux.
    C помощью mapStateToProps мы достает данные из стейта и передаем их в презентационную компоненту
    C помощью mapDispatchToProps мы передает, как правило, thunkTC или actionAC с помощью которых можем изменять стейт