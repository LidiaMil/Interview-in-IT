ОГЛАВЛЕНИЕ:
-простые вопросы:   1-10
11. function Expression от function Declaration
12-13 замыкание
13-161 всё остальное:)


1. Как правильно подключать скрипт и чем отличается атрибуты asinc и defer?
    Либо перед закрывающим тегом body либо с атрибутом defer.
    async приостанавливает парсинг html-документа на момент выполнения скриптов, а c defer парсинг html-документа не прерывается



2. Типы данный. Чем отличается null от undefined?
    1 string 2 number 3 boolean 4 object 5 null 6 undefined 7 bigInt 8 Symbol
    null пустое значение(явно присваивается), а undefined неприсвоенное по умолчанию



3. Что не нравится в js?
    typeof null // 'object'

    let name = prompt('?');
    name; //выведит null

    работа с дробными числами: 0.1 + 0.2 // 0.30000000008 и т.п.



4. Чем отличается == от ===?
    == сравнивает только значения, а === значения и тип данных



5. Что будет, если undefined привести числовому значению?
    +undefined // NaN



6. Переопределите переменные
    let a = 10,
        b = 25;

    a = a + b;
    b = a - b;
    a = a - b;

    let c;
    c = a;
    a = b;
    b = c;



7. Как нумеруются элементы массива?
    0, 1, 2, 3 ...



8. Что возвращает typeof для массивов?
    'object'



9. У кого есть свойство length?
    Только у массивов, у объектов нет.



10. Какие значения переменных можно копировать?
    Все, кроме объектов и массивов, т.к. мы копируем только ссылки на массивы и объекты, а не их самих.



11. Чем отличаются function Expression от function Declaration?
    Областью видимости.
    У FD не будет ошибки, если вызвать функцию выше, а у FE будет.
    Так из-за работы компилятора кода, т.к. он будет собирать сначала все var, let и т.д. и поднимает их вверх,
    но не присваивает значения.



12. Что такое замыкание?
    Это функция со всеми внешними переменными, доступными ей.



13. Синтаксис замыкания
    (function() {
        .....

    ,})();



14. Зачем придумали создавать классы в JavaScript?
    1. Когда описание объекта длинное.
    2. Нужно создавать такие объекты в нескольких местах кода
    3. Нужны приватные свойства и методы



15. Что такое контекст?
    this. Для доступа к информации внутри объекта
    Значение this - это объект перед точкой.



16. Какие методы у функций для установки контекста вам известны и отличие call от apply?
    Bind - только устанавливает контекст и передает параметры, но не вызывает функцию к работе
    Call - устанавливает контекст, передает параметры раздельно и вызывает функцию
    Apply - устанавливает контекст, передает параметры в виде массива и вызывает функцию, в функции параметры
    принимаются по-прежнему как раздельные.



17. Как удалить объекта класса?
    var vasya = new Person('Vasia');
    vasya = null;



18. Принципы ООП
    Инкапсуляция:
    Это процесс сокрытия части реализации интерфейса от пользователя.

    Наследование:
    Это возможность наследовать свойства и методы других классов.

    Полиморфизм:
    Само слово означает много форм. Идея заключается в способности вызывать один и тот же метод для разных объектов,
    и при этом каждый объект реагирует по-своему. Чтобы это произошло полиморфизм использует наследование.
    class Human {
      constructor(name) {
        this.name = name;
      }
      say() {
        return `Hello, my name is ${this.name}, I like travelling`;
      }
    }

    class Men extends Human {
      constructor(name) {
        super(name)
      }
      // Берем метод say у родителя.
    }

    class Coder extends Human {
      constructor(name) {
        super(name)
      }
      say() {
        // Переопределяем метод родителя say для отображения нового значения.
        return `Hello, my name is ${this.name}, I like coding`;
      }
    }
    const alex = new Men('Alex');
    const leo = new Coder('Leo');
    alex.say() // "Hello, my name is Alex, I like travelling"
    leo.say() // "Hello, my name is Leo, I like coding"

    Абстракция
    Так вот, Абстрактные классы также как и многие родители вовсе и знать не знают зачем ребенку-потомку это будет нужно,
    и как он это будет использовать, но уверены, что так НАДО! Т.е. такие классы содержат абстрактные методы,
    которые являют собой объявление метода без самой реализации, как фантик без конфетки, тем самым обязывая потомка, этот метод реализовать.



19. Что такое __proto__?
    Это свойство объекта-наследника, хранящее в себе ссылку на объект-прототип
    (работает только для чтения значений свойств из объекта-наследника).



20. Что такое prototype?
    Это свойство функции-конструктора класса, хранящее в себе ссылку на объект-прототип (хранилище, чаще
    всего, методов класса в данном контексте).



21. Что такое прототип?
    Это объект, от которого наследуются свойства или методы.



22. Написать метод, который будет для любого массива подсчитывать сумму его элементов.
    Array.prototype.getSum = function() {
        var sum = 0;
        for (var i = 0; i < this.length; i++) {
            sum += this[i];
        }
        return sum;
    }



23. Способы прототипного наследования.
    Rabbit.prototype.__proto__ = Animal.prototype;
    Rabbit.prototype = Object.create(Animal.prototype);



24. Являются ли примитивы instanceof своего класса?
    Нет. 4 instanceof Number // false



25. Как реализуются в классе публичные свойства и методы? А приватные свойства и методы? Описать для двух стилей ООП.
    функциональный стиль:
    this.name = name; - публичное св-во
    this._name = name; - защищенное св-во
    name(Когда записываем в аргумент и просто его используем) - приватное св-во
    function getFormattedAge() {  - пишется в самом классе. Приватный метод
        return ываы;
    }
    this.showInfo = function() { - публичный метод
        аыпап
    };

    прототипный стиль
    this.name = name; - публичное св-во
    this._name = name; - приватное св-во
    Person.prototype._getFormattedAge() {  - пишется за пределами класса. Приватный метод
        return ываы;
    }
    Person.prototype.showInfo = function() { - публичный метод
        аыпап
    };



26. Когда используется переменная self?
    При объявлении, в родителе, вообще не использовать this, а получать контекст через замыкание
    const self = this;



27. Зачем создаются геттеры и сеттеры?
    Для управляемого доступа к состоянию объекта используют специальные функции, так называемые «геттеры» и «сеттеры».
    Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию – «геттер» (getter method).
    Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод,
    который называют «сеттер» (setter method).



28. Что такое защищенные свойства и методы? Когда они используются?
    Такие свойства и методы не должны быть доступны извне
    Защищённые свойства обычно начинаются с префикса _



29. Что такое chaining?
    Вызов методов в строку друг за другом через точку.



30. Для чего предназначен метод hasOwnProperty() ?
    Вызов obj.hasOwnProperty(prop) возвращает true, если свойство prop принадлежит самому объекту obj, иначе false.



31. Что делает метод Object.create(null) ?
    Создаём объект с нулевым прототипом



32. Какое главное отличие функционального стиля ООП от прототипного? В чем их плюсы и минусы?
    В функциональном стиле при создании объекта в каждый объект копируются все методы классаБ
    а в прототипном все объекты будут ссылаться на один прототип с методами. Поэтому он экономнее.



33. Какие сортировки вам известны? Опишите принцип работы хотя бы 2-х.
    Глупая, пузырьковая, шейкерная, четно-нечетная, сортировка расчёской



34. Как получать все стилевые описания для элемента?
    window.getComputedStyle(element);



35. Как правильно задавать стили?
    Через добавление класса. Если анимация, то можно через style.



36. Как склонировать объект?
    1 способ.
    var a = JSON.parse(JSON.stringify(a));

    2 способ.
    Это глубое клонирование объекта. Отдельно копируем каждый тип данных.
    Для массивов и объектов вызываем рекурсивный вызов.



37. Как сделать, чтоб при изменениях в одной вкладке это данные изменялись и в другой автоматически?
    Для этого есть событие storage.
    window.onstorage = function() {
        изменения, которые хотим произвести;
    }



38. Какие методы вы знаете?
    GET, POST, PUT, DELETE, PATCH(пас)



39. Что такое API?
    Это интерфейс(на бэкэнде), который содержит в себе обработчики потенциально предполагаемых запросов и
    выступает связующим звеном между клиентом и базой данных.



40. Какие должны быть GET-запросы?
    Идемпотентные. То есть сколько бы раз мы не делали запрос - мы всегда должны получать один и тот же ответ.



41. Что такое фолбек?
    Реализация резервного(аварийного) режима, т.е. обеспечивание хотя бы неполного или неудобного функционала
    в случае отсутствия поддержки полной функциональности.



42. Каким языком является JS?
    Javascript - однопоточный (один стэк вызовов) и синхронный язык программирования (пока выполняется одно действие - другие не выполняются)



43. Какой у вас на курсах был Git Flow?
    Для ДЗ создавали отдельные ветки, а потом создавали PR.



44. Что вам нравится из es6?
    Например, стрелочные функции.
    1. Всегда анонимные, не анонимными могут являться лишь при объявлении функции через Function Expression, например
    const func = () => {}
    2. Работают с внешним контекстом this - в некоторых случаях удобная замена выражения var self = this;
    const btn = document.getElementById('button');
    3. Не имеют доступа к массиву arguments
    const numbers = [1, 2, 3];

    numbers.forEach(number => {
        console.log(arguments); // Uncaught ReferenceError: arguments is not defined
    });



45. Что такое babel?
    Babel - это JavaScript-компилятор из версий ES6+ в ES5



46. Что вернет операция - typeof function ?
    'function'



47. Для чего предназначен метод parseFloat() ? Опишите принцип работы.
    Преобразует значение из строки в целое или дробное число. Когда встречает недопустимый символ,
    (не цифру, не минус, не точку) преобразование останавливается. Если допустимых символов не было,
    то возвращает NaN.



48. Для чего предназначен метод parseInt() ? Опишите принцип работы.
    Преобразует значение из строки в целое. Когда встречает недопустимый символ,
    (не цифру, не минус) преобразование останавливается. Если допустимых символов не было,
    то возвращает NaN.



49. Что вернет следующая запись - !!Infinity ?
    true


50. Что вернет следующая запись - !!NaN ?
    false


51. В чём отличие циклов while и do-while?
    Разница с циклом while заключается в том, что условие проверяется в конце итерации цикла,
    а не в начале.



52. Что делает команда "return" в функции?
    Оператор return завершает выполнение текущей функции и возвращает её значение.



53. Что такое чистая функция? Напишите пример.
    Это функция, которая всегда для одних и тех же входных значений возвращает одинаковый результат и не изменяет ничего снаружи себя.
    function clean(a, b) {
        return a + b;
    }

    clean(2, 2)



54. Что такое функция-callback? Чем она может быть полезна? Дать развернутый ответ.
    Это функция, передающаяся как параметр в другую функцию, полученный код функции-коллбэка может вызываться внутри принимающей функции.



55. Что такое область видимости? Какие они бывают? Что способно ограничивать область видимости в языке JavaScript?
    Все переменные в JavaScript имеют определенную область видимости, в пределах которой они могут действовать.
    Все переменные, которые объявлены вне функций, являются глобальными.
    Переменная, определенная внутри функции, является локальной.
    Ограничивать способны функции, в ES6 еще фигурные скобки.



56. Зачем придумали строгий режим "use strict"? Какие моменты он отслеживает, приведите пример?
    Используется для того, чтоб перевести код в режим полного соответсвия современному стандарту.
    добавить выражение "use strict" в начало кода JavaScript, тогда strict mode будет применяться для всего кода
    добавить выражение "use strict" в начало тела функции, тогда strict mode будет применяться только для этой функции
    Определение глобальных переменных в функциях может вести к потенциальным ошибкам. Чтобы их избежать используется строгий режим или strict mode.
    Еще используем, например, для исключения дублирования ключей в объекте, дублирования аргументов.



57. Что такое Window? Из чего он состоит?
    Объект window — предсозданный объект, содержит свойства и методы для управления окном браузера. Состоит из DOM, BOM и JavaScript.
    Все глобальные объекты, функции и переменные JavaScript автоматически становятся членами window object.
    Глобальные переменные - это свойства window object.
    Глобальные функции - это методы window object.
    Даже document object (HTML DOM) является свойством window object.
    window.location (Возвращает объект с информацией об URL открытого в окне документа)
    window.document (Возвращает документ, открытый в окне браузера)
    window.scrollX, window.scrollY (Возвращают, насколько прокручена страница в окне браузера — соответственно вправо и вниз. Некроссбраузерны)
    window.outerWidth, window.outerHeight (Возвращают полный размер окна браузера — соответственно ширину и высоту. Некроссбраузерны.)

    Объект window.location — предсозданный объект, содержит свойства и методы для управления URL-ом, открытым в окне браузера.
    Общий вид URI:
    протокол://хост:порт/путь?запрос#закладка



58. Что такое BOM? Назовите 2-3 его возможности.
    Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением),
    чтобы работать со всем, кроме документа.
    Состоит из navigator (даёт информацию о самом браузере и операционной системе. )
    screen ( информация о экране)
    location (позволяет получить текущий URL и перенаправить браузер по новому адресу)
    frames (работа с iframe)
    history (работа с history API(история браузера))
    XMLHttpRequest (AJAX запросы. То есть запросы с фронтэнда на сервер за какими-либо данными)



59. Что такое DOM-дерево? DOM-объект?
    DOM-дерево – это представление HTML-документа в виде дерева тегов. Вот как оно выглядит:
    ▾
    HTML
    ▾
    HEAD
    #text ↵␣␣␣␣
    ▾
    TITLE
    #text О лосях
    #text ↵␣␣
    #text ↵␣␣
    ▾
    BODY
    #text Правда о лосях.

    Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.
    Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
    Например:
    // заменим цвет фона на красный,
    document.body.style.background = "red";



60. Какие виды узлов бывают в DOM?
    1. Document - входная точка в DOM.
    2. Теги являются узлами-элементами. Они образуют структуру дерева: <html> – это корневой узел, <head> и <body> его дочерние узлы и т.д.
    3. Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста.
    У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
    Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM.
    4. Комментарии



61. В чем особенности метода document.getElementById() ?
    Возвращает один элемент, а не коллекцию.
    Поиск возможен только у document. Имя id передаем без решетки.



62. Что возвращает метод document.getElementsByTagName() ?
    Возвращают коллекции элементов.
    Поиск возможен и для ранее найденных элементов
    paragraphs = block.getElementsByTagName('p'),
    paragraph = paragraphs[1];



63. Что такое коллекция? В чем ее особенности?
    DOM-коллекции, такие как childNodes и другие не являются JavaScript-массивами.
    В них нет методов массивов, таких как forEach, map, push, pop и других.
    Она является живой.



64. Почему лучше использовать команды document.getElement(s)By* чем document.querySelector() ?
    document.querySelector() возвращает только один элемент - первый, подходящий под селектор
    Поиск возможен и для ранее найденных элементов
    Селектор записывается уже с . и # и может быть составным, также возможен поиск по атрибуту
    Эти методы работают дольше, чем getElement(s)By*
    Коллекция, возвращаемая методом querySelectorAll не является живой - не реагирует на добавление/удаление элементов



65. Чем отличаются свойства el.parentNode и el.offsetParent?
    el.parentNode возвращает ссылку на родительский узел (может быть текстовым)
    el.offsetParent возвращает ссылку на ближайшего позиционированного предка (у которого position не равен static), а если такого нет - на body.



66. Чем отличаются свойства el.childNodes и el.children?
    el.childNodes возвращает коллекцию из всех дочерних узлов (в т.ч. текстовых). Возвращается Node List.
    el.children возвращает коллекцию из всех дочерних узлов-тегов. Возвращает html-коллекцию.



67. Как задать HTML-содержимое элементу? Что будет если использовать эту команду с += ?
    Устанавливает html-содержимое (передающееся в виде строки !) в block
    При этом перезаписывается всё предыдущее содержимое block
    block.innerHTML = '<span>Привет</span>';
    Добавляет в конец имеющейся разметки новую
    block.innerHTML += '<span>Привет</span>';

    Устанавливает новый текст в block
    При этом перезаписывается всё предыдущее html и текстовое содержимое block
    block.textContent = 'Привет';
    Добавляет в конец имеющегося текста новый
    При этом имеющийся текст сохраняется, а вот теги, его оборачивавшие - нет
    block.textContent += 'Привет';



68. Как работает метод el.insertAdjacentHTML() ?
    The insertAdjacentHTML() method inserts a text as HTML, into a specified position.
    el.insertAdjacentHTML(position, text)
    Legal position values are:
    "afterbegin"
    "afterend"
    "beforebegin"
    "beforeend"



69. Что такое data-атрибуты и зачем они нужны?
    С помощью нестандартных атрибутов можно привязать к элементу данные, которые будут доступны в JS.
    Например data-name. Стандарт HTML% специально разрешает атрибуты data-* и резервирует их для
    пользовательских данных.
    Притом к таким атрибутам можно обратиться как к свойствам с помощью спец свойства dataset
    <div id="elem" data-about="Elephant">

    <script> alert(elem.dataset.about) //Elephant </script>
    Дефис в имени атрибута трансформируется в CC.



70. Как работает метод el.classList.toggle() ?
    el.classList.toggle('name')
    Если класса name нет, то добавляет его, если есть - удаляет.



71. Что такое DOM-свойства?
    При написании HTML-кода вы можете определить атрибуты HTML элементов. Как только браузер проанализирует ваш код, будет создан соответствующий узел DOM.
    Этот узел является объектом, и поэтому у него есть свойства.
    Например:
    <input id="name" type="text" value="Вася">
    После того, как браузер проанализирует этот код, будет создан объект HTMLInputElement:   Вася
    Созданный объект будет содержать десятки свойств, таких как: accept, accessKey, align, alt, assignedSlot, attributeStyleMap, attributes, autocapitalize,
    autocomplete, autofocus, baseURI, checked, childElementCount, childNodes, children, classList, className, clientHeight и другие.

    Еще популярные свойства: classList(для работы с contains, add, remove, toggle), className(для установки названия класса).



72. Какие группы событий вы знаете? Перечислите 3 группы.
    При взаимодействии мыши со страницей могут возникать следующие виды событий:
    mousedown	при нажатии кнопки мыши на элементе
    mouseup	при отпускании кнопки мыши на элементе
    click	при щелчке мышью на элементе
    dblclick	при двойном щелчке мышью на элементе
    mouseover	при попадании курсора мыши на элемент
    mouseout	при покидании курсором мыши элемента
    mousemove	при движении курсора мыши по элементу
    mousewheel	при вращении колеса мыши над элементом

    При взаимодействии мыши с перетаскиваемыми (drag&drop) элементами и элементами, над которыми идёт перетаскивание,
    могут происходить следующие виды событий (не поддерживаются на мобильных):
    dragstart	у перетаскиваемого элемента, когда пользователь нажал левую кнопку мыши, т.е. начал перетаскивать элемент
    drag	    у перетаскиваемого элемента при каждом перемещении мыши
    dragend	    у перетаскиваемого элемента, когда пользователь отпустил кнопку мыши, т.е. закончил перетаскивать элемент
    dragenter	у элемента-приёмника, когда в него входит перетаскиваемый элемент
    dragleave	у элемента-приёмника, когда из него выходит перетаскиваемый элемент
    drop	    у элемента-приёмника, когда в нём находится перетаскиваемый объект и левая кнопка мыши отпускается

    При взаимодействии пальца со страницей на сенсорном экране могут возникать следующие виды событий:
    touchstart	при прикосновении пальцем к элементу
    touchend	при отпускании пальца от элемента
    touchmove   при перемещении прижатого к элементу пальца

    При взаимодействии клавиатуры со страницей могут возникать следующие виды событий:
    keydown	    при вжатии клавиши	input, textarea, select, a, button	window
    keyup	    при отпускании клавиши	input, textarea, select, a, button	window
    keypress	при вжатии клавиши, соответствующей печатному символу

    При работе форм и взаимодействии пользователя с элементами, которые могут получать фокус ввода (элементы форм, ссылки) могут возникать следующие виды событий:
    select	        при выделении текста в текстовом поле
    focus и focusin	при получении элементом фокуса, т.е. выделении элемента мышью или клавиатурой, или вызове метода элемент.focus()
    blur и focusout	при потере элементом фокуса, т.е. выделении другого элемента или вызове метода элемент.blur()
    change	        при изменении значения элемента ввода;
    input	        при изменении значения текстового поля, возникает сразу при внесении изменения (некроссбраузерно)
    copy, cut, paste    при операциях копирования, вырезания, вставки
    submit	        при отсылке формы на сервер, но не при вызове форма.submit()
    reset	        при сбросе содержимого формы, но не при вызове форма.reset()



73. Какие способы установки обработчика события вы знаете?
    el.onсобытие = function
    Когда для элемента произойдёт событие, будет вызвана функция.
    Установленный таким образом обработчик можно отменить: el.onсобытие = null

    el.addEventListener(событие, function, режим (true/false)) (изначально установлено false, то есть обработчик)
    Удалить событие можно через el.removeEventListener(событие, funcsion, режим)



74. Подробно опишите, как работает метод el.addEventListener() ?
    Установка перехватчика либо обработчика события в коде JavaScript вызовом метода HTML-элемента:
    el.addEventListener(событие, function, режим)
    Когда для элемента произойдёт событие, будет вызвана функция.
    Если режим равен true, будет установлен перехватчик, если false (или если не указан) — обработчик.
    При выполнении обработчика или перехватчика (т.е. функции) ему будет доступна переменная this,
    которая указывает на элемент, которому был установлен обработчик или перехватчик



75. В чем разница между способами установки обработчиков событий через el.addEventListener() и el.on*() ?
    Для addEventListener можно задать режим (обработчик либо перехватчик)
    С помощью addEventListener можно задавать сколько угодно однотипных обработчиков событий для одного элемента,
    тогда как если повесить два обработчика на одно и то же событие с помощью on - последний перезапишет
    предыдущий (пример в консоли)



76. Как удалить обработчик события, установленный через addEventListener() ?
    el.removeEventListener(событие, function, режим)


77. Как удалить обработчик события, установленный через on* ?
    el.onсобытие = null



78. Чем отличается обработчик от перехватчика?
    Обработчик. При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе,
    затем выше и так далее, вверх по цепочке вложенности.

    Перехватчик. Перехватчики сработают в порядке «сверху-вниз»: FORM → DIV → P. при нажатии на P. То есть он работает на стадии погружения



79. Что такое объект event, для чего он нужен?
    Event - объект с информацией о произошедшем событии (пример в консоли)
    Если к данному объекту планируется обращаться по его предзаданному имени - параметр в функции-коллбэке можно не указывать
    Используется, например, при делегировании событий для понятия, на каком элементе произошло событие(event.target)



80. Как вы понимаете термин "всплытие"(bubbling) события?
    Основной принцип всплытия:
    При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее,
    вверх по цепочке вложенности. Например, есть 3 вложенных элемента FORM > DIV > P, с обработчиком на каждом:

    Всплытие гарантирует, что клик по внутреннему <p> вызовет обработчик onclick (если есть) сначала на самом <p>,
    затем на элементе <div> далее на элементе <form>, и так далее вверх по цепочке родителей до самого document.
    Событие focus не всплывает.



81. Чем отличается свойство event.target от event.currentTarget?
    Каждый обработчик имеет доступ к свойствам события:
    event.target – самый глубокий элемент, на котором произошло событие. (p)
    event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (до которого «доплыло» событие). (div)



82. Какие методы предотвращения всплытия вам известны?
    Остановка всплытия через event.stopPropagation():
    - Выполняются ВСЕ обработчики клика дочернего блока (горизонтально)
    - Вертикального всплытия не происходит, обработчик клика родительского блока не выполняется

    Остановка всплытия через event.stopImmediatePropagation():
    - Выполняется только первый обработчик клика дочернего блока
    - Все последующие обработчики клика дочернего блока (горизонтальные) не выполняются
    - Вертикального всплытия не происходит, обработчик клика родительского блока не выполняется

    Предотвращение обработки клика по блоку-ссылке браузером по-умолчанию (например, клик по ссылке ведет на адрес href) через event.preventDefault():
    - По клику на дочерний блок-ссылку выполнятся все обработчики клика и происходит всплытие
    - Однако редиректа после этого не происходит



83. Как работает метод event.stopPropagation() ?
    Остановка всплытия через event.stopPropagation():
    - Выполняются ВСЕ обработчики клика дочернего блока (горизонтально)
    - Вертикального всплытия не происходит, обработчик клика родительского блока не выполняется



84. Как работает метод event.stopImmediatePropagation() ?
    Остановка всплытия через event.stopImmediatePropagation():
    - Выполняется только первый обработчик клика дочернего блока
    - Все последующие обработчики клика дочернего блока (горизонтальные) не выполняются
    - Вертикального всплытия не происходит, обработчик клика родительского блока не выполняется



85. Для чего предназначен метод event.preventDefault() ?
    Предотвращение обработки клика по блоку-ссылке браузером по-умолчанию (например, клик по ссылке ведет на адрес href) через event.preventDefault():
    - По клику на дочерний блок-ссылку выполнятся все обработчики клика и происходит всплытие
    - Однако редиректа после этого не происходит



86. Что такое делегирование событий, для чего используется и как оно реализуется?
    Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того,
    чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка.
    Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.
    table.onclick = function(event) {
      var target = event.target; // где был клик?

      if (target.tagName == 'TD') {
      highlight(target); // подсветить TD
      }
    };



87. Есть таблица с тысячей строк. По клику на каждую строку я хочу окрасить ее в красный. Как это грамотно реализовать?
    table.onclick = function(event) {
      var target = event.target; // где был клик?

      if (target.tagName == 'TR') {
        target.classList.add('bgColor');
      }
    };



88. Чему равен this в обработчике события?
    this – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
    this (=event.currentTarget) всегда будет сама форма (form), так как обработчик сработал на ней.



89. Что такое JSON? В чем его польза?
    JSON (JavaScript object notation) — популярный формат представления сложноструктурированных данных, позволяющий в виде строки представить скалярное значение,
    значение массива либо хэша. По сути, JSON полностью совпадает с синтаксисом, которым в JS задаются числа, строки, объекты.

    Зачем нужен JSON?
    Так как формат JSON — это исключительно текст, его легко можно посылать на сервер и обратно.
    При этом данные в этом формате могут использоваться любым языком программирования.
    Зачем нужен:
    1.Обмен данными
    В обмене между браузером и сервером могут участвовать только данные в текстовом формате.
    JSON как раз и является таким текстовым форматом.
    2. Отправка данных
    Если у вас есть данные в виде объекта JavaScript, то вы можете преобразовать их в формат JSON и отправить на сервер:
    3.Получение данных
    Если вы получили данные в формате JSON, то вы можете преобразовать их в объект JavaScript.
    4. Хранение данных
    Когда необходимо сохранить данные, то независимо от того, где происходит сохранение, данные должны быть в некоем формате.
    Текстовый формат всегда был и остается до сих пор одним из допустимых форматов данных.



90. Какие методы для работы с JSON-форматом вы знаете?
    1.JSON.stringify
    преобразует выражение в JSON-строку и возвращает её;
    не может быть вызван для объектов некоторых типов;
    информация о типе может быть потеряна — например, объекты типа Date представляются в виде строки;
    если указаны пробелы — результат будет красиво отформатирован с отступами в виде указанного количества пробелов
    2.JSON.parse
    преобразует строку в формате JSON в соответствующее ей значение и возвращает его;
    если указана функция — она может преобразовывать некоторые свойства возвращаемого объекта к нужному типу



91. Что такое LocalStorage? В чем его польза? Как долго в нем хранятся данные?
    Объект веб-хранилища localStorage позволяет хранить пары ключ/значение в браузере.
    Данные, которые записаны LS, сохраняются после обновления страницы и даже после перезапуска браузера.
    localStorage.clear();
    localStorage.setItem('name', 'Vasya');
    localStorage.getItem('name')
    


92. В чем отличие LocalStorage от SessionStorage?
    Данные, которые записаны в LS, сохраняются после обновления страницы и даже после перезапуска браузера.
    В случае SS сохраняются только при перезагрузке страницы. При открытии новой вкладки или закрытии браузера они пропадают.



93. Что происходит после того, как пользователь ввел в адресную строку путь сайта и нажал Enter?
    Происходит HTTP запрос.
    - Сначала идет DNS-запрос - поиск ближайшего DNS-сервера, чтобы преобразовать URL(например, google.com)
    в его числовое представление - IP-адрес. Этот адрес будет реальным адресом сайта в интернете;
    - соединение - установка соединения с сервером по полученному IP-адресу;
    - отправка данных;
    - ожидание ответа - ждем пока пакеты данных дойдут до сервера, он их обработает и ответ вернет назад;
    - получение данных.



94. Как удалось ускорить общение между клиентом и сервером? С помощью каких двух технологий и как они работают?
    1.Убрали разрыв соединения при получении ответа на запрос. Появился режим постоянного соединения(keep-alive).
    При первом запросе происходит соединение, которое не разрывается.
    2.Параллельные HTTP соединения. Сделали 8, в ручную можно увеличить до 16.
    3.HTTP конвейер. Когда браузер может послать несколько GET-запросов в одном соединении, не дожидаясь ответа сервера.



95. Что такое AJAX?
    AJAX (аббревиатура от «Asynchronous Javascript And Xml») – технология обращения к серверу без перезагрузки страницы.
    За счёт этого уменьшается время отклика и веб-приложение по интерактивности больше напоминает десктоп.
    Несмотря на то, что в названии технологии присутствует буква X (от слова XML), использовать XML вовсе не обязательно.
    Под AJAX подразумевают любое общение с сервером без перезагрузки страницы, организованное при помощи JavaScript.



96. Подробно опишите работу метода xhr.open().
    1-й параметр - метод запроса:
    2-й параметр - URL запроса:
    - может использоваться как относительный, так и абсолютный
    3-й параметр - асинхронность:
    - если выставлен в true - запрос асинхронный (по умолчанию), работа страницы во время отправки запроса не блокируется
    - если выставлен в false - запрос синхронный, работа страницы во время отправки запроса блокируется

    xhr.open('GET', 'https://reqres.in/api/users?page=2', true); // успешный запрос (код 200) - попадем в onload



97. Что такое cookie?
    Небольшой фрагмент данных, отправленный веб-сервером и хранимый на пк пользователя. Веб-браузер каждый раз
    при попытке открыть страницу соответствующего сайта пересылает куки веб-сервису в составе HTTP-запроса.
    Куки - это пары данных по типу ключ-значение. Чего всего хранит простые настройки отображения сайта.



98. В чем разница между GET и POST запросами?
    POST передает данные в теле запроса, а GET в URL.

    Метод запроса GET:
    - направлен чаще всего на получение данных из базы
    - если запрос идет не на API *, а на обычную страницу сайта - чаще всего вернется HTML-разметка данной страницы
    - данные для сервера передаются только в урле

    Метод запроса POST:
    - используется для отправки данных, добавления чего-то нового в базу данных
    - данные для сервера передаются в теле запроса, но могут отправляться и доп. параметры в урле.



99. Как или в каком виде мы можем отправлять данные на сервер?
    Формат отправки данных - кодировка multipart/form-data:
    - данные передаются в методе send() объектом класса FormData
    - способ чаще используется для отправки данных простых форм, т.к. будет не совсем корректно работать с массивами и объектами
    function() {
        var xhr = new XMLHttpRequest();

        xhr.open('POST', 'https://reqres.in/users?page=2');

        var formData = new FormData();

        formData.append('age', 25);
        formData.append('data', [{}]);

        xhr.send(formData);
    };

    Формат отправки данных - кодировка application/json:
    - данные передаются в методе send() json-строкой
    - потребуется выставить специальный заголовок запроса
    - способ подходит для отправки сложных структур
    function() {
        var xhr = new XMLHttpRequest();

        xhr.open('POST', 'https://reqres.in/users');

        xhr.setRequestHeader('Content-Type', 'application/json');

        xhr.send(JSON.stringify({
            age: 25,
            data: [{}]
        }));
    };



100. Какой запрос будет считаться кросс-доменным?
    1. http://www.site.com (другой домен, именно www)
    1. Другой домен org, com, by ...
    2. Другой протокол http, https.
    3. Другой порт site.com:8080



101. Подробно опишите, что произойдет, если в блоке try возникает исключение?
    Исключение — ситуация времени выполнения, которая НЕ останавливает программу,
    но делает бессмысленным продолжение её выполнения.
    Обработка исключений — планирование реакции программы на возникновение исключений.
    Синтаксис:
    try {
      операторы, при выполнении которых может возникнуть исключение
    }
    catch ( переменная ) {
      операторы, реагирующие на возникновение исключения
    }
    Если при выполнении операторов внутри try возникает исключение, то:
    оставшиеся операторы блока try не будут выполнены;
    будут выполнены операторы из блока catch;
    стандартной реакции браузера на возникновение исключения (окно с ошибкой, вывод ошибки в консоль...) не будет,
    т.к. исключение считается обработанным, т.к. оно «словлено» блоком catch;
    После выполнения всех операторов в блоке try (если исключение не возникло)
    или после выполнения всех операторов в блоке catch (если исключение возникало) управление будет передано операторам, идущим после try...catch.
    Переменная в блоке catch при возникновении исключения получит объект с информацией
    об исключении, содержащий свойства name (тип исключения) и message (текст исключения).
    Пример:
    try {
      console.log('до ошибки');
      var a=bbbbb;
      console.log('после ошибки');
    }
    catch ( ex ) {
      console.error('возникло исключение!');
      console.error('тип исключения: '+ex.name);
      console.error('текст исключения: '+ex.message);
    }
    до ошибки
    возникло исключение!
    тип исключения: ReferenceError
    текст исключения: bbbbb is not defined


102. Как породить исключение в блоке try/catch самостоятельно?
    1. Исключение можно породить («бросить») самостоятельно, если исключительная ситуация обнаружена программным способом,
    или если механизм обработки исключений используется для других целей.
    Синтаксис: throw выражение
    При выполнении оператора throw возникнет исключение, и переменной в блоке catch будет присвоено значение выражения.
    Для унификации кода в блоке catch, работающего и с встроенными исключениями и с порождёнными вручную,
    имеет смысл в операторе throw в качестве выражения передавать хэш, содержащий свойства name и message.
    Пример:
    try {
      console.log('до генерации исключения');
      throw { name:'MyError', message:'что-то пошло не так!' };
      console.log('после генерации исключения');
    }
    catch ( ex ) {
      console.error('возникло исключение!');
      console.error('тип исключения: '+ex.name);
      console.error('текст исключения: '+ex.message);
    }
    до генерации исключения
    возникло исключение!
    тип исключения: MyError
    текст исключения: что-то пошло не так!

    2. - Порождать ошибку можно также через throw new Error('Something went wrong')



103. Какие способы оптимизации скорости загрузки страницы вам известны?
    1. Уменьшение HTTP-запросов.
    2. Помещать css-файлы в начале страницы.
    3. Помещение js в конец страницы.
    4. Минификация css и js.
    5. Использование поддоменов для параллельного скачивания.
    6. Искользовать кэш браузеров.
    7. Искользование CDN для загрузки популярных js библиотек.
    8. Оптимизация изображений.
    9. Не маштабировать изображения.
    10. Использовать Gzip-сжатие.



104. Что такое CDN?
    CDN - сокращение от content delivery network, то есть "сеть доставки контента". Чаще всего это множество серверов со спец ПО,
    которые ускоряют доставку("отдачу") контента конечному пользователю. Сервера расположены по всему миру таким образом,
    чтобы время ответа посетителям сайта было минимальным. Под "контентом" чаще всего подразумевают видео и статические элементы
    веб-сайтов(не требующие выполнения кода на сервере или запросов в базу данных, такие как css/js), но к "контенту" относятся и
    совсем неожиданные вещи - например, игры в Стиме(использует CDN для отдачи игр), обновление для операционных систем и т.д.



105. Что такое полифилл?
    Полифилл (polyfill) — библиотека (скрипт), добавляющая в старые браузеры поддержку возможностей, которые в современных браузерах являются встроенными.
    Полифиллы позволяют разработчику в своих скриптах пользоваться современными возможностями без оглядки на их неполную поддержку;
    когда поддержка нужных возможностей станет повсеместной — скрипты менять не потребуется, достаточно просто отключить ненужный уже полифилл.



106. Как выполнить функцию с задержкой? Опишите принцип работы метода.
    Метод setTimeout
    function func() {
      alert( 'Привет' );
    }
    setTimeout(func, 1000);

    setTimeout(function() { alert('Привет') }, 1000);

    или с передачей параметров
    function func(phrase, who) {
      alert( phrase + ', ' + who );
    }
    setTimeout(func, 1000, "Привет", "Вася"); // Привет, Вася



107. Как запускать выполнение функции через определенный промежуток времени? Опишите принцип работы метода.
    Метод setInterval имеет синтаксис, аналогичный setTimeout.
    Смысл аргументов – тот же самый. Но, в отличие от setTimeout, он запускает выполнение функции не один раз,
    а регулярно повторяет её через указанный интервал времени. Остановить исполнение можно вызовом clearInterval(timerId).
    // начать повторы с интервалом 2 сек
    var timerId = setInterval(function() {
      alert( "тик" );
    }, 2000);

    // через 5 сек остановить повторы
    setTimeout(function() {
      clearInterval(timerId);
      alert( 'стоп' );
    }, 5000);



108. В чем разница между setInterval() и рекурсивным setTimeout() ?
    Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval, так как время до следующего выполнения можно запланировать по-разному,
    в зависимости от результатов текущего.
    Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.
    Давайте сравним два кода. Первый использует setInterval:
    var i = 1;
    setInterval(function() {
      func(i);
    }, 100);

    Второй использует рекурсивный setTimeout:
    var i = 1;
    setTimeout(function run() {
      func(i);
      setTimeout(run, 100);
    }, 100);

    При setInterval внутренний таймер будет срабатывать чётко каждые 100 мс и вызывать func(i)
    Реальная пауза между вызовами func при setInterval меньше, чем указана в коде, так как в паузу входит также время на выполнение функции.
    Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.
    При рекурсивном setTimeout задержка всегда фиксирована и равна 100 мс.



109. Как остановить работу интервала?
    Остановить исполнение можно вызовом clearInterval(timerId).
    // начать повторы с интервалом 2 сек
    var timerId = setInterval(function() {
      alert( "тик" );
    }, 2000);

    // через 5 сек остановить повторы
    setTimeout(function() {
      clearInterval(timerId);
      alert( 'стоп' );
    }, 5000);



110. Каким языком является JavaScript? Что значат эти понятия?
    Javascript - однопоточный (один стэк вызовов) и синхронный язык программирования (пока выполняется одно действие - другие не выполняются)
    Однопоточный значит, что в JS есть один стэк вызовов.
    Синхронный значит, что пока выполняется одно действие - другие не выполняются



111. Что такое однопоточность?
    JavaScript сам по себе однопоточный, что означает то, что только один блок кода может запускаться за раз.
    Так как движок JS выполняет наш код, обрабатывая строку за строкой, он использует один стек вызова, чтобы продолжать отслеживать код,
    который выполняется в соответствии с установленным порядком. Тоже самое, что и делает стек — структура данных,
    которая записывает строки выполняемых инструкций и выполняет их в стиле LIFO, то есть Last In First Out,
    что переводится как, “последний пришел — первый обслужен”.



112. Что такое синхронность?
    Что означает синхронность? Скажем, что у нас есть 2 строчки кода. Первая идет за второй.
    Синхронность означает то, что строка 2 не может запуститься до тех пор, пока строка 1 не закончит своё выполнение.



113. Что такое Event Loop и как он работает?
    Event Loop (Или цикл обработки событий)
    Цикл событий или Event Loop — ответственный за взятие первого элемента из очереди задач и передачу его в стек запросов, только тогда, когда стек пуст и свободен. На этом шаге нашего уравнения, стек запросов пуст. Это, своего рода, очередь, куда мы складываем сыбытия.
    https://stasonmars.ru/javascript/polnoe-ponimanie-syncronnogo-i-asyncronnogo-javascript-s-async-await/



114. Что такое Queue? По какому принципу работает?
    Туда мы попадает, только если заходили в WebAPI. То есть туда будут попадать колбэки, наши функции.



115. Что такое Stack? По какому принципу работает?
    Вызов любой функции создает контекст выполнения (Execution Context).
    При вызове вложенной функции создается новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).
    То, что приходит в стэк первым - уходит последним. "First-in - last-out"



116. Что содержится в WebAPI?
    Команты, которые относятся к BOM и DOM. То есть не к JS. То есть в WebAPI мы попадаем только в том случае, в CallStack попало какое-то действие,
    которое JS сам по себе не знает. Например, setTimeout, AJAX-запрос, какая-то отрисовка в DOM.



117. Для чего используют setTimeout(func, 0) ?
    setTimeout(func, 0) используется для того, чтобы какое-либо действие выполнилось последним в рамках функции
    Это планирует вызов func настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.
    Так вызов функции будет запланирован сразу после выполнения текущего кода.



118. Что такое регулярное выражение и из чего оно состоит?
    Регулярное выражение — шаблон, кодирующий ожидаемый формат строки. С помощью регулярного выражения можно проверить,
    содержатся ли в некоей строке подстроки, соответствующие шаблону, и получить из этих подстрок какие-либо осмысленные части.
    Регулярное выражение задаётся с указанием шаблона и ключей.



119. Опишите два способа задать регулярное выражение.
    Создать объект класса RegExp можно двумя способами, с указанием литерала шаблона:
    var переменная=/шаблон/ключи;
    или с указанием строкового выражения шаблона:
    var переменная=new RegExp(шаблон,ключи);
    Второй вариант синтаксиса удобен, когда регулярное выражение заранее точно не известно и нужно его скомпоновать динамически, программно.



120. В чем преимущество объявления регулярного выражения через объект класса RegExp?
    var переменная=new RegExp(шаблон,ключи);
    Второй вариант синтаксиса удобен, когда регулярное выражение заранее точно не известно и нужно его скомпоновать динамически, программно.



121. Какие флаги есть у регулярного выражения и для чего они служат?
    i	- При проверке соответствия строки шаблону не различать строчные и прописные буквы (с русскими буквами работает корректно).
    g	- Искать в строке все подходящие под шаблон подстроки, а не только самую первую.
    m	- Многострочный поиск, т.е. трактовать проверяемую строку как содержащую несколько строк, разделённых символами перевода строки.



122. Какие методы для работы с регулярными выражениями вам известны?
    str.search(reg), str.match(reg) без флага g, str.match(reg) c флагом g, str.split(reg, limit) (alert('12-34-56'.split(/-/)) // [12, 34, 56]),
    str.replace(reg, str) (alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56), regexp.test(str), regexp.exec(str)



123. Как работает метод str.match(reg) с флагом и без флага g?
    str.match(reg) без флага g
    В этом случае str.match(reg) находит только одно, первое совпадение.
    Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами index – позиция,
    на которой оно обнаружено и input – строка, в которой был поиск.
    var str = "ОЙ-Ой-ой";
    var result = str.match( /ой/i );
    alert( result[0] ); // ОЙ  (совпадение)
    alert( result.index ); // 0 (позиция)
    alert( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

    str.match(reg) с флагом g
    При наличии флага g, вызов match возвращает обычный массив из всех совпадений.
    Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.
    var str = "ОЙ-Ой-ой";
    var result = str.match( /ой/ig );
    alert( result ); // ОЙ, Ой, ой



124. Как работает метод str.replace(reg, str) ?
    // заменить дефис на двоеточие
    alert('12-34-56'.replace("-", ":")) // 12:34-56
    При вызове со строкой замены replace всегда заменяет только первое совпадение.
    Чтобы заменить все совпадения, нужно использовать для поиска не строку "-", а регулярное выражение /-/g, причём обязательно с флагом g:
    // заменить дефис на двоеточие
    alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56



125. Какой событие необходимо использовать, чтоб изменения в input моментально передавались?
    Событие input(onInput) срабатывает тут же при изменении значения текстового элемента и поддерживается всеми браузерами, кроме IE8-.

    Пример использования (не работает в IE8-):
    <input type="text"> oninput: <span id="result"></span>
    <script>
      var input = document.body.children[0];

      input.oninput = function() {
        document.getElementById('result').innerHTML = input.value;
      };
    </script>
    В современных браузерах oninput – самое главное событие для работы с элементом формы. Именно его, а не keydown/keypress следует использовать.



126. Что такое arguments?
    Полный список аргументов, с которыми вызвана функция, доступен через arguments.
    Это псевдомассив, который имеет свойство length, а элементы индексируются начиная с нуля.
    Но при это он не может обращаться к встроенным методам Array, таким как forEach() или map().
    Стрелочные функции не имеют arguments



127. Какие есть методы для работы с объектами?
    1. Метод Object.assign()
    Копирует значения из одного объекта в другой.
    const character = Object.assign(name, details);
    Также можно сделать спред оператором
    const character = {...name, ...details}

    2. Метод Object.create()
    Позволяет создавать новые объекты и соединять их с прототипами существующих объектов.

    3. Object.keys()
    Создает массив ключей объекта в виде массива.

    4. Метод Object.values()
    Создает массив значений объекта.

    5. Метод Object.entries()
    Создает вложенный массив пар «ключ-значение» объекта.
    const operatingSystem = {
        name: 'Ubuntu',
        version: 18.04,
        license: 'Open Source'
    };
    const entries = Object.entries(operatingSystem);
    console.log(entries);
    [["name", "Ubuntu"] ["version", 18.04] ["license", "Open Source"] ]

    6. Метод Object.freeze()
    Предотвращает модификацию свойств и значений объекта и добавление или удаление свойств объекта.

    7. Метод Object.seal()
    Предотвращает добавление новых свойств объекта, но позволяет изменять существующие свойства. Этот метод похож на Object.freeze().

    8. Метод Object.getPrototypeOf()
    Используется для получения внутреннего скрытого [[Prototype]] объекта, также доступного через свойство __proto__.



128. Что создает область видимости?
    В JavaScript области видимости создаются блоками, функциями и модулями.
    Переменные, объявленные с помощью ключевых слова const и let могут иметь блочную, функциональную или модульную область видимости,
    а переменные, объявленные с помощью ключевого слова var, не имеют блочной области видимости.
    Объект не имеет своей области видимости



129. Promise
    Это специальный объект, у которого есть 3 статуса: pending, resolve, reject. Изначально promise в статусе pending.
    У промиса есть 2 функции, соответсвующие resolve(разрешить) и reject(отклонить),
    они принимают только 1 аргумент(либо 1 примитив, либо 1 объект). После вызова одной из этих функций наш пропис или ресолвится
    или реджектится и это состояние остается с ним навсегда. Его состояние изменить уже больше нельзя.

    У промиса есть 3 метода: then, catch, finally.
    Then может принимать 2 колбека. 1й обрабатывает resolve, 2 - reject. Все эти колбеки, если они что-нибудь возвращают,
    они возвращают новый промис в состоянии resolve. Если происходит явное присвоение ошибки( throw new Error, throw),
    то тогда в состоянии reject.
    Метод catch равносилен второму колбеку в then. Он обрабатывает ошибки
    Метод finally отрабатывает всегда. Нужен для того, чтоб выполнять какие-либо сайд-эффекты.

    let b = new Promise((res, rej) => {
        setTimeout(() => {
            res(`My name is`)
        }, 1000)
    }).then(data => {
        let onSuccess = (start: any) => `${start} Vania`
        return onSuccess(data)
    }).then(result => {
        let print = (param: any) => console.log(param)
        return print(result)
    })

    Метод all() используется тогда, когда нам не важно, в каком порядке выполняются функции, помещенные в метод, но
    /важно, что должно выполниться по заверешении работы всех этих функций в совокупности
    Promise.all([createFirstPromise(5), createSecondPromise(-5)])



130. Async, await
    Существует специальный синтаксис для работы с промисами, который называется «async/await»
    У слова async один простой смысл: эта функция всегда возвращает промис.
    async function f() {
      return 1;
    }
    f().then(alert)

    Есть другое ключевое слово – await, которое можно использовать только внутри async-функций.
    Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится.
    После чего оно вернёт его результат, и выполнение кода продолжится.

    В этом примере промис успешно выполнится через 1 секунду:
    async function f() {

      let promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve("готово!"), 1000)
      });

      let result = await promise; // будет ждать, пока промис не выполнится (*)
      alert(result); // "готово!"
    }
    f();
    В данном примере выполнение функции остановится на строке (*) до тех пор, пока промис не выполнится.
    Это произойдёт через секунду после запуска функции. После чего в переменную result будет записан результат выполнения промиса,
    и браузер отобразит alert-окно «готово!».
    Обратите внимание, хотя await и заставляет JavaScript дожидаться выполнения промиса, это не отнимает ресурсов процессора.
    Пока промис не выполнится, JS-движок может заниматься другими задачами: выполнять прочие скрипты, обрабатывать события и т.п.
    По сути, это просто «синтаксический сахар» для получения результата промиса, более наглядный, чем promise.then.



131. Каррирование
    Каррирование – это трансформация функций таким образом, чтобы они принимали аргументы не как f(a, b, c), а как f(a)(b)(c).
    function curry(f) { // curry(f) выполняет каррирование
      return function(a) {
        return function(b) {
          return f(a, b);
        };
      };
    }

    // использование
    function sum(a, b) {
      return a + b;
    }

    let carriedSum = curry(sum);
    alert( carriedSum(1)(2) )

    //ПРИМЕР ЧАСТИЧНОГО ПРИМЕНЕНИЙ
    f(a)(b, c)



132. Методы массивов
    0. Метод flat()
    Метод flat() возвращает новый массив, в котором все элементы вложенных подмассивов
    были рекурсивно "подняты" на указанный уровень depth.
    var arr1 = [1, 2, [3, 4]];
    arr1.flat();
    // [1, 2, 3, 4]


    1. forEach
    Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
    ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
      alert(`${item} имеет позицию ${index} в ${array}`);
    });
    Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.


    2. indexOf/lastIndexOf и includes
    методы, которые помогут найти что-нибудь в массиве.
    Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое,
    что и их строковые аналоги, но работают с элементами вместо символов:
    arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
    arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
    arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
    Например:
    let arr = [1, 0, false];
    alert( arr.indexOf(0) ); // 1
    alert( arr.indexOf(false) ); // 2
    alert( arr.indexOf(null) ); // -1
    alert( arr.includes(1) ); // true


    3. find и findIndex
    let result = arr.find(function(item, index, array) {
      // если true - возвращается текущий элемент и перебор прерывается
      // если все итерации оказались ложными, возвращается undefined
    });


    4.filter
    Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.
    На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
    Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:
    let results = arr.filter(function(item, index, array) {
      // если true - элемент добавляется к результату, и перебор продолжается
      // возвращается пустой массив в случае, если ничего не найдено
    });

    ПРЕОБРАЗУЮЩИЕ МЕТОДЫ
    5. map
    Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.
    Синтаксис:
    let result = arr.map(function(item, index, array) {
      // возвращается новое значение вместо элемента
    });
    Например, здесь мы преобразуем каждый элемент в его длину:
    let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
    alert(lengths); // 5,7,6


    6. sort
    Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
    Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
    let arr = [ 1, 2, 15 ];
    // метод сортирует содержимое arr
    arr.sort();
    alert( arr );  // 1, 15, 2

    Порядок стал 1, 15, 2. Это неправильно! Но почему?
    По умолчанию элементы сортируются как строки.
    Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок,
    и действительно выходит, что "2" > "15".
    Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().
    Функция должна для пары значений возвращать:
    function compare(a, b) {
      if (a > b) return 1; // если первое значение больше второго
      if (a == b) return 0; // если равны
      if (a < b) return -1; // если первое значение меньше второго
    }
    Например, для сортировки чисел:
    function compareNumeric(a, b) {
      if (a > b) return 1;
      if (a == b) return 0;
      if (a < b) return -1;
    }
    или
        function compareNumeric(a, b) {
            return a - b
        }
    let arr = [ 1, 2, 15 ];
    arr.sort(compareNumeric);
    alert(arr);  // 1, 2, 15


    7. reverse
    Метод arr.reverse меняет порядок элементов в arr на обратный.
    let arr = [1, 2, 3, 4, 5];
    arr.reverse();
    alert( arr ); // 5,4,3,2,1
    Он также возвращает массив arr с изменённым порядком элементов.


    8. reduce/reduceRight
    Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.
    Они используются для вычисления какого-нибудь единого значения на основе всего массива.
    Синтаксис:
    let value = arr.reduce(function(previousValue(acc, item, index, array) {
      // ...
    }, [initial]);
    previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial)
    let arr = [1, 2, 3, 4, 5];
    let result = arr.reduce((sum, current) => sum + current, 0);
    alert(result); // 15



133. Сортировка пузырьком
    function bubbleSort(arr) {
        let length = arr.length;
                // length - 1 - потому что в массиве длиной, например в 3 элемента - требуется всего 2 операции сравнения
                // length - 1 - i - при каждом прохождении сортировки слева-направо - вправо "всплывает" наибольший либо
                // наименьший элемент, соответственно нет нужды включать в процесс сравнения вытесненные в конец
                // отсортированные элементы
                // i - номер прохождения сортировки слева-направо, если оно 0е - в конце у нас нет "всплывших" элементов,
                // 1е - значит 1 элемент и т.д.
                // т.е. на каждом прохождении сортировки слева-направо - становится на одну пару для сравнения меньше
        for (let i = 0; i < length - 1; i++) {
            for (let j = 0; j < (length - 1 - i); j++) {
                if (arr[j] > arr[j+1]) {                    // аналог if (a > b) {}
                    let temp = arr[j];                      // var c = a;
                    arr[j] = arr[j+1];                      // var a = b;
                    arr[j+1] = temp;                        // var b = c;
                }
            }
        }
        return arr;
    }
    bubbleSort([33, 103, 3, 726, 200, 984, 198, 764, 9]);



134. Классы
    В JavaScript класс – это разновидность функции.
    Базовый синтаксис выглядит так:
    class User {
      constructor(name) {
        this.name = name;
      }

      sayHi() {
        alert(this.name);
      }
    }
    let user = new User("Иван");
    user.sayHi();


    Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д
    Вот пример user.name, реализованного с использованием get/set:
    class User {
      constructor(name) {
        // вызывает сеттер
        this.name = name;
      }

      get name() {
        return this._name;
      }

      set name(value) {
        if (value.length < 4) {
          alert("Имя слишком короткое.");
          return;
        }
        this._name = value;
      }
    }
    let user = new User("Иван");
    alert(user.name); // Иван
    user = new User(""); // Имя слишком короткое.


    Чтобы конструктор Rabbit работал, он должен вызвать super() до того, как использовать this, чтобы не было ошибки:
    class Animal {
      constructor(name) {
        this.speed = 0;
        this.name = name;
      }
      // ...
    }

    class Rabbit extends Animal {
      constructor(name, earLength) {
        super(name);
        this.earLength = earLength;
      }
      // ...
    }
    // теперь работает
    let rabbit = new Rabbit("Белый кролик", 10);
    alert(rabbit.name); // Белый кролик
    alert(rabbit.earLength); // 10

    Защищённые свойства обычно начинаются с префикса _
      _waterAmount = 0;

    Свойства только для чтения
    Для этого нам нужно создать только геттер, но не сеттер

    СТАТИЧЕСКИЙ МЕТОД КЛАССА:
    Свойства и методы являются статическими, если они не привязаны к конкретному экземпляру класса и имеют одинаковое
    значение в независимости от того, какой экземпляр ссылается на них
    static getName() {
        return 'Vanya'
    }
    Статичные методы принадлежат объекту класса, но недоступны другим объектам того же класса. Т.е. если создать
    экземпляр класса, то к статичным методам обратиться не получиться


135. this
    Значение this – это объект «перед точкой», который использовался для вызова метода.
    Значение this вычисляется во время выполнения кода и зависит от контекста.
    Стрелочные функции особенные: у них нет своего «собственного» this.
    Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.



136. Для чего используется doctype?
    Для указания типа документа. Служит для того, чтобы бразер понимал, как ему интерпритировать страницу.
    <!DOCTYPE html>



137. Базовая разметка страницы
    <!DOCTYPE html>
    <html lang="en">

    <head>
        F<meta charset="UTF-8">
        <title>Walking Dog</title>
        <link rel="icon" type="image/svg+xml" href="./media/images/favicon/dog.svg">

        <link rel="stylesheet" href="css/main.css">
    </head>

    <body>
    .....
    <script src=""> </script>
    </body>
    </html>



138. Реализовать метод bind используя apply.
    Function.prototype._bind = function(ctx, ...args) {
        return (...args2) => this.apply(ctx, [...args, args2])
    }



139. Proto, prototype
   prototype - это объект. prototype есть у функций(кроме стрелочных) и классов.
   У всех объектов есть proto. Proto - это ссылка на prototype функции, которая создала этот объект
   Всё внутри передается по ссылке. Если мы дошли до где proto = null, а это самый нижний уровень,
   это результат prototype Object, то у нас вылетает ошибка.
   У class prototype защищен, его нельзя просто так перезаписать, в то время у функций-конструкторов
   prototype перезаписывается без проблем.
   Правило хорошего тона получения prototype: let proto = Object.getPrototype(test)



140. Методы строк
    1. Изменение регистра
    Методы toLowerCase() и toUpperCase() меняют регистр символов:
    alert( 'Interface'.toUpperCase() )

    2. Поиск подстроки
        str.indexOf
        let str = 'Widget with id';
        alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
        alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
        alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

        str.lastIndexOf(substr, position)
        Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.

    3. includes
    str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

    4. Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:
       alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
       alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

    5.Получение подстроки
        str.slice(start [, end])
        Возвращает часть строки от start до (не включая) end.
        let str = "stringify";
        // 'strin', символы от 0 до 5 (не включая 5)
        alert( str.slice(0, 5) );

        str.substring(start [, end])
        Возвращает часть строки между start и end.
        Это — почти то же, что и slice, но можно задавать start больше end.
        let str = "stringify";
        // для substring эти два примера — одинаковы
        alert( str.substring(2, 6) ); // "ring"
        alert( str.substring(6, 2) ); // "ring"

        str.substr(start [, length])
        Возвращает часть строки от start длины length.
        let str = "stringify";
        // ring, получаем 4 символа, начиная с позиции 2
        alert( str.substr(2, 4) );

    6. str.trim()
    убирает пробелы в начале и конце строки.

    7.str.repeat(n)
    Повторяет строку n раз.



141.Методы чисел
    Math.floor(num)
    Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.

    Math.ceil(num)
    Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.

    Math.round(num)
    Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

    Math.trunc(num) (не поддерживается в Internet Explorer)
    Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.

    toFixed(n)
    n - количество знаков после запятой
    Помните, что метод toFixed всегда возвращает строку

    isNaN(value)
    Преобразует значение в число и проверяет является ли оно NaN:

    isFinite(value)
    преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:
    alert( isFinite("15") ); // true
    alert( isFinite("str") ); // false, потому что специальное значение: NaN
    alert( isFinite(Infinity) ); //false

    parseInt(num)
    parseInt возвращает целое число

    parseFloat(num)
    возвращает число с плавающей точкой:

    Math.random()
    Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

    Math.max(a, b, c...) / Math.min(a, b, c...)
    Возвращает наибольшее/наименьшее число из перечисленных аргументов.

    Math.pow(n, power)
    Возвращает число n, возведённое в степень power
    alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

    Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
    Например:
    let num = 255;
    alert( num.toString(16) );  // ff
    alert( num.toString(2) );   // 11111111



142. fetch
    Метод fetch() — современный и очень мощный, поэтому начнём с него. Он не поддерживается старыми (можно использовать полифил),
    но поддерживается всеми современными браузерами.
    Базовый синтаксис:
    let promise = fetch(url, [options])
    url – URL для отправки запроса.
    options – дополнительные параметры: метод, заголовки и так далее.
    Без options это простой GET-запрос, скачивающий содержимое по адресу url.
    fetch('http://example.com/movies.json')
      .then((response) => {
        return response.json();
      })
      .then((data) => {
        console.log(data);
      });



143. Принципы SOLID
    https://m-habr-com.cdn.ampproject.org/c/s/m.habr.com/ru/amp/post/505430/

    1. S – Single Responsibility (Принцип единственной ответственности)
    Каждый класс должен отвечать только за одну операцию.

    2. O — Open-Closed (Принцип открытости-закрытости)
    Классы должны  быть  открыты для расширения, но закрыты для модификации.

    3.L — Liskov Substitution (Принцип подстановки Барбары Лисков)
    Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе,
    могут заменяться объектами типа П без негативных последствий для функциональности программы.

    4. I — Interface Segregation (Принцип разделения интерфейсов)
    Не следует ставить клиент в зависимость от методов, которые он не использует.

    5. D — Dependency Inversion (Принцип инверсии зависимостей)
    Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций.
    Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.



144. Map, Set объекты
    Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
    let map = new Map();
    Методы и свойства:
    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.

    Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
    let set = new Set();
    Основная «изюминка» – это то, что при повторных вызовах set.add() с одним и тем же значением ничего не происходит,
    за счёт этого как раз и получается, что каждое значение появляется один раз.
    Его основные методы это:
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.



145. Примеры принципов LIFO(last in first out) и FIFO(First In First Out)
    Стек и очередь(например, массив с методами push и shift)



146. WebSocket
    Протокол WebSocket обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение.
    Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
    WebSocket особенно хорош для сервисов, которые нуждаются в постоянном обмене данными, например онлайн игры,
    торговые площадки, работающие в реальном времени, и т.д.

    Простой пример
    Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
    let socket = new WebSocket("ws://javascript.info");



147. Чем отличаются Sql-БД(MySQL) от noSql-БД(MongoDB)?
    Реляционная (SQL) и нереляционная (NoSQL) структуре БД
    SQL БД имеют форму таблиц, а в NoSQL БД данные представляются в виде документов,
    пар «ключ-значение», графов или хранилищ wide-column.


148. KISS
    Keep it simple, stupid
    Это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности.
    Есть два варианта расшифровки аббревиатуры: «keep it simple, stupid» и более корректный «keep it short and simple».



149. Отличие библиотеки(react) от фреймворка(angular, vue)
    В библиотеке код управляет кружением(можно подключать какие-либо библиотеки и т.п.),а в фрейворкте всё уже написано за нас,
    т.е. надо следовать каким-либо жестким правилам



150. Что такое PWA
    Progressive web application
    Технология в web-разработке, которая визуально и функционально трансформирует сайт в приложение (мобильное приложение в браузере).
    Пользователь думает, что он использует моб приложение, но оно сохраняет свою нативность и раскрывается в моб браузере
    Это происходит благодаря Service Worker
    Service Worker — это JavaScript-файл, который запускается в фоновом режиме как автономный сервис.
    Он не связан с DOM (Document Object Model) или web-страницами, работает на другом потоке и получает доступ к DOM с помощью API postMessage.



151. Two-way-binding
    Двухсторонний поток данный(используется в Angular). Мы меняет state - у нас меняется отображение, мы меняет отображение -
    у нас меняется state.
    В React односторонний поток данных.



152. Что такое XSS-атака
    Тип атаки на веб-системы, заключающийся во внедрении в выдаваемую веб-системой страницу вредоносного кода
    (который будет выполнен на компьютере пользователя при открытии им этой страницы) и взаимодействии этого кода
    с веб-сервером злоумышленника.



153. Отличие микротаски от макротаски
    Микрозадачи(микротаски) приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микротаской.
    Микротаски также используются «под капотом» await, т.к. это форма обработки промиса.

    Макротаски(например, setTimeOut, setInterval) попадают в macrotask queue

    Сразу после каждой макротаски движок исполняет все задачи из очереди микротасок перед тем,
    как выполнить следующую макротаску или отобразить изменения на странице, или сделать что-то ещё.
    etTimeout(() => alert("timeout"));
    Promise.resolve()
      .then(() => alert("promise"));
    alert("code");

    Какой здесь будет порядок?
    1. code появляется первым, т.к. это обычный синхронный вызов.
    2. promise появляется вторым, потому что .then проходит через очередь микротасок и выполняется после текущего синхронного кода.
    3. timeout появляется последним, потому что это макротаска.

    Все микротаски завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макротаске.



154. Что такое HTTP?
    HyperText Transfer Protocol — «протокол передачи гипертекста»
    HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы.
    Протокол HTTP  лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия,
    что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser).
    Полученный итоговый документ будет (может) состоять из различных поддокументов являющихся частью итогового документа:
    например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.



155. Из чего состоит HTTP-запрос?
        Method (GET, POST etc.)
        PATH (наш урл, т.е. путь к ресурсу)
        Version of the protocol (HTTP/1.1)
        Headers (отправляют доп информацию на сервер)
        body (тело запроса с инфой, например, у PUT-запроса)



156. Server Sent Events
    Server-Sent Events описывает встроенный класс EventSource, который позволяет поддерживать соединение с сервером и получать от него события.
    Как и в случае с WebSocket, соединение постоянно.

    Но есть несколько важных различий:
    WebSocket	                                                                                EventSource
    Двунаправленность: и сервер, и клиент могут обмениваться сообщениями	Однонаправленность: данные посылает только сервер
    Бинарные и текстовые данные	                                                                Только текст
    Протокол WebSocket	                                                                        Обычный HTTP

    Зачем нам его использовать?
    Основная причина: он проще. Многим приложениям не требуется вся мощь WebSocket.



157. for...in, for...of
    const names = ['first', 'second', 'third']

    for(let index in names) {
        console.log(index)   // 0, 1, 2
        console.log(names[index])  // 'first', 'second', 'third'
    }

    for(let name of names) {
        console.log(name)  // 'first', 'second', 'third'
    }



158. В чем различие между свойствами и атрибутами?
    При написании исходного кода HTML вы можете определить атрибуты для своих элементов HTML.
    Затем, как только браузер проанализирует ваш код, будет создан соответствующий узел DOM. Этот узел является объектом, и поэтому он имеет свойства .

    Например, этот элемент HTML:
    <input type="text" value="Name:">
    имеет 2 атрибута ( type и value ).

    Как только браузер проанализирует этот код, будет создан объект HTMLInputElement, и этот объект будет содержать десятки свойств,
    таких как: accept, accessKey, align, alt, атрибуты, автофокус, baseURI, checked, childElementCount, childNodes,
    children, classList, className, clientHeight и т. Д.



159. Паттерны(ответ недописан)
    Паттерн — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

    CREATIONAL DESIGN PATTERNS
    1.Constructor
    Позоволяет создавать объекты нового типа.
    class Server {
      constructor(name, ip) {
        this.name = name
        this.ip = ip
      }

      getUrl() {
        return `https://${this.ip}:80`
      }
    }
    const aws = new Server('AWS German', '82.21.21.32')
    console.log(aws.getUrl())


    2. Singleton
    Это объект, который есть в системе в одном экземпляре, плюс к нему есть какая-то глобальная точка доступа.
    Нужен, когда объект в системе должен быть в едином экземпляре и доступ к нему должен быть из разных частей программы.
    Например, корзина в интернет-магазине
    let instance
    class Counter {
        constructor() {
            if (!instance) instance = this
            return instance
        }
    }

    3. Prototype

    4. Factory
    Фабричный метод - это творческий шаблон проектирования, который предоставляет интерфейс для создания объектов в суперклассе,
    но позволяет подклассам изменять тип создаваемых объектов.


    STRUCTURAL DESIGN PATTERNS
    1. Adapter
    Позволяет интегрировать старый интерфейс какого-то класса в новый интерфейс класса и позволяет им работать совместно

    Publisher/Subscriber

    Observer
    Наблюденческий паттерн проектирования, который создает механизм подписки, позволяющий одним объектам следить за
    изменением других объектов. Используется в Redux для изменения state.
    Пример использования: любая подписка на новостные ленты ресурса.

    State
    Поведенческий паттерн, который позволяет менять объектам своё поведение в зависимости от состояния.

    Proxy



160. Хеш-таблица
    Это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение)
    и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.
    
161. Что такое СУБД?

    Допустим, есть большая база данных, которой пользуются многие сотрудники: кто-то ищет информацию, а кто-то изменяет или даже удаляет её. Чтобы правильно обрабатывать все эти запросы, нужно специальное программное обеспечение, и именно такое ПО получило название системы управления базами данных (СУБД).
